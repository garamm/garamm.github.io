---
layout: post
title: "[책/뇌를 자극하는 알고리즘] 11. 알고리즘 성능 분석"
author: 임가람
date: "2021-09-22 14:24:00"
categories: [책, 뇌를 자극하는 알고리즘]
tags: [뇌를 자극하는 알고리즘]
---

## 알고리즘의 성능에 대하여
알고리즘의 우수함을 가리는 기준에는 여러 가지가 있지만, 다음 5가지가 대표적인 측정 기준이다.<br>
- 정확성: 정확하게 동작하는가?
- 작업량: 얼마나 적은 연산을 수행하는가?
- 메모리 사용량: 얼마나 적은 메모리를 사용하는가?
- 단순성: 얼마나 단순한가?
- 최적성: 더 이상 개선할 여지가 없을 만큼 최적화되어 있는가?

<br>

---
## 알고리즘 수행 시간의 분석
수행 시간은 좋은 CPU와 나쁜 CPU에서 각각 테스트 해보면 차이가 발생하기 때문에 물리적인 측정 방식으로는 불가능하다. 그러므로 컴퓨터의 성능에 관계 없이 명확하게 정의될 수 있으며 필요한 경우 이미 알려진 수행 시간을 바탕으로 입력 데이터의 크기 변화에 대한 수행 시간의 변화를 예측할 수 있어야 한다. 알고리즘 수행 시간으로 '작업량'을 활용할 수 있다. 알고리즘의 수행 시간 분석은 다음 세 가지를 찾는 것이 목표이다.<br>
- 최악의 경우
- 평균의 경우
- 최적의 경우

<br>

---
## 점근 표기법(Asymptotic Notation)
알고리즘의 수행 시간을 대략적으로 나타내는 방법을 말한다. 알고리즘의 성능 차이는 대규모의 데이터를 다룰 때 확연하게 드러난다. <br>
예를 들어 데이터 집합 크기 n에 대하여 데이터 집합을 정렬하는데 필요한 비교 작업 횟수가 한 알고리즘은 $n^2+5n$이고, 다른 알고리즘은 $27n$이라고 할 때 데이터 집합의 크기에 따른 성능은 다음과 같다.<br>

|$n$|$n^2+5n$|$27n$|
|---|---|---|
|1|6|27|
|10|150|270|
|100|10,500|2,700|
|1,000|1,005,000|27,000|
|10,000|100,050,000|270,000|
|100,000|10,000,500,000|2,700,000|
|1,000,000|1,000,005,000,000|27,000,000|
|10,000,000|100,000,050,000,000|270,000,000|
|100,000,000|10,000,000,500,000,000|2,700,000,000|
|1,000,000,000|1,000,000,005,000,000,000|27,000,000,000|

n이 무한대에 가까워질수록 $n^2+5n$에서는 $5n$의 영향이 아주 작아지고, $27n$의 계수 27도 영향이 아주 작아진다. 이처럼 데이터 집합의 크기가 커질수록 계수화 최고차 항을 제외한 나머지 항의 효과는 거의 없어진다. 그래서 점근 표기법에서는 최고차 항으로만 알고리즘의 성능을 '대략적으로' 표시한다. 점근 표기법은 알고리즘의 성능을 단순화해서 표현하기 때문에 알고리즘 간의 성능 비교가 용이하다는 장점이 있다.<br>
대표적으로 사용하는 점근 표기법에는 3가지가 있다.<br>
- $O$(Big O) 표기법: 최악의 경우의 성능(수행 시간의 상한을 나타낼 때 사용, 어떤 최악의 상황에서도 그 성능을 보장한다는 뜻, 가장 많이 사용됨).
- $\Omega$(Big Omega) 표기법: 최선의 경우의 성능(수행 시간의 하한을 나타낼 때 사용, 아무리 좋은 케이스라도 그 성능 이상을 낼 수 없다는 것을 의미)
- $\Theta$(Big Theta) 표기법: 수행 시간의 상한과 하한을 동시에 나타낼 때 사용

<br>

### O(Big O) 표기법
대문자 $O$를 쓰고 그 옆에 괄호를 쓰고 괄호 안에 증가 함수(입력 데이터 크기 $n$에 대해 알고리즘의 수행 시간이 늘어나는 비율을 나타내는 함수)를 넣어주면 된다.<br>
예를 들어 데이터 크기 $n$에 대해 최대의 수행 시간이 $2n^2+4n$인 알고리즘의 경우 점근 표기법에서는 최고차 항을 제외한 나머지 모든 항과 모든 계수를 제거하므로 $4n$을 제거하고 $2n^2$의 계수 2를 제거하면 증가 함수는 $n^2$이 된다. 그러므로 이 증가 함수를 $O$ 표기법으로 나타내면 $O(n^2)$이 된다.<br>
버블 정렬과 삽입 정렬의 증가 함수 $\dfrac{n^2}{2}$는 $O$ 표기법으로 나타내면 $O(n^2)$이 된다.<br>
<br>
점근 표기법은 증가 함수를 단순화한다는 특성 때문에 알고리즘의 성능을 대표적인 몇 가지 유형으로 추릴 수 있는 장점이 있다. 아래 표는 자주 볼 수 있는 $O$ 표기법으로 표현한 알고리즘의 성능이다.<br>

|가 함수|설명|알고리즘|
|---|---|---|
|$O(1)$|최악의 경우에도 일정한 상수 시간에 종료되는 것을 의미|해시테이블|
|$O(\log_{2}{n})$|최악의 경우에도 입력 값 $n$이 증가하는 속도보다 수행 시간이 증가하는 속도가 느린 알고리즘의 성능을 나타냄<br>이러한 성능을 가진 알고리즘은 n이 10일 때 수행시간이 3.32이며, $n$이 10,000이 됐을 때도 여전히 13.29에 불과하다.<br>입력이 1000배가 늘어나도 수행 시간은 고작 4배 정도 늘어난다.|이진 탐색|
|$O(n)$|최악의 경우 입력 값 $n$만큼의 수행 시간을 요구하는 성능, 입력 값 $n$이 증가하는 속도만큼 수행 시간도 같은 속도로 증가한다.|순차 탐색|
|$O(n\log{n})$|로그 함수가 사용되기는 했지만, $O(\log_{2}{n})$와는 비교할 수 없을 정도로 수행시간이 길다. $O(n)$ 알고리즘보다 훨씬 수행 시간이 길다.|병합 정렬, 퀵 정렬|
|O(n^2)|최악의 경우 값 n에 대해 제곱으로 수행 시간이 늘어나는 성능, 똑같이 $n$회만큼 반복하도록 되어 있는 for문이 2개 중첩되어 있으면 이런 성능이 나타남|버블 정렬, 삽입 정렬|
|$O(n^3)$|이러한 성능의 알고리즘은 입력 값 n에 대해 3제곱으로 수행 시간이 증가함|행렬 곱셈|
|$O(2^n)$|입력 값 $n$에 대해 최대 2의 $n$제곱 만큼 수행 시간이 증가하는 경우, $n$이 10이라고 해도 수행 시간은 1024가 된다.||

$O(n^2)$은 점근적 상한 수행 시간이 $n^2$을 넘지 않는 모든 증가 함수의 '집합'이다. 예를 들어 어느 알고리즘의 증가 함수는 $2n^2+4n$이고 또 어떤 알고리즘의 증가 함수는 $37n+5$라고 한다면, 이 두 알고리즘의 수행 시간은 모두 점근적으로 $n^2$을 넘어서지 않으므로 이들의 수행 시간은 $O(n^2)$이라고 할 수 있다.<br>
![Big O 표기법](/assets/img/posts/2021-09-22-algorithm-performance-analysis-1.png){: width="700" height="150" }

<br>

### $\Omega$(Big Omega) 표기법
$\Omega$ 표기법은 '수행해야 하는 최소한의 수행 시간'을 나타내기 위해 사용한다. $O$ 표기법과 반대된다.<br>
예를 들어 어느 알고리즘이 최선의 경우에도 $3n^2+8n$의 증가율을 가진다고 했을 때, 점근 표기법에 의해 계수 3과 $8n$항을 제거해야 하고 기호 $\Omega$와 괄호를 사용하여 $\Omega(n^2)$이라고 표현한다.<br>
$\Omega(n^2)$는 $O(n^2)$와 반대로 점근적 하한 수행 시간이 $n^2$보다 크거나 같은 증가 함수들을 부분집합으로 가진다. $2n^2+4n, \dfrac{n^2}{2}$와 같은 증가 함수는 차수가 같으므로 $\Omega(n^2)$에 포함되고, $3n^2$과 같이 차수가 더 높은 증가 함수도 포함된다.<br>
![Big Omega 표기법](/assets/img/posts/2021-09-22-algorithm-performance-analysis-2.png){: width="700" height="150" }

<br>

### $\Theta$(Big Theta) 표기법
$\Theta$ 표기법은 $O$ 표기법(점근적 상한)과 $\Omega$ 표기법(점근적 하한)을 모두 만족시키는 증가 함수를 뜻한다.<br>
<br>
$\Theta(f(n)) = O(f(n)) \cap \Omega(f(n))$<br>
<br>
$O$ 표기법은 점근적 증가율이 자신의 증가 함수를 '넘어서지 않는' 모든 증가 함수를 포함하고, $\Omega$ 표기법은 점근적 증가율이 자신의 증가 함수를 '작지 않은' 모든 증가 함수를 포함한다.<br>$\Theta$ 표기법은 두 표기법과는 다르게 점근적으로 자신의 증가율과 같은 증가 함수만을 포함한다.<br>
![Big Theta 표기법](/assets/img/posts/2021-09-22-algorithm-performance-analysis-3.png){: width="700" height="150" }

<br>

---
## 재귀 알고리즘의 성능 분석
### 재귀 방정식과 재귀 알고리즘
재귀 방정식: 자기 자신을 항으로 갖는 방정식<br>
예를 들어 팩토리얼(Factorical)의 경우 숫자 8 팩토리얼은 다음과 같다.<br>
<br>
$8! = 8 \times 7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1$<br>
<br>
위 식은 아래와 같이 바꿀 수 있다.<br>
<br>
$8! = 8 \times 7!$<br>
<br>
즉 $n!$은 $n \times (n-1)!$로 바꿔 표현할 수 있다. 이와 같은 성질을 이용하여 팩토리얼을 재귀 방정식으로 나타내면 다음과 같다.<br>

$
f(n)= \begin{cases}
1,\qquad n=0, n=1 \\\\\\
n \times f(n-1),\qquad n>1
\end{cases}
$

<br><br>

재귀 방정식은 재귀 알고리즘의 수행 시간(즉, 성능)을 나타내는 또 하나의 표현방법이다.<br>
아래 예제 코드를 재귀 방정식을 이용해 성능 분석을 해보자.
```c
int RecurrenceSum( int Data[], int SizeOfData )
{
    if( SizeOfData == 1 )
        return Data[0];
    else
        return RecurrenceSum ( &Data[i], SizeOfData - 1 ) + Data[0];
}
```
RecurrenceSum() 함수는 자기 자신을 같은 방법으로 계속 호출하다가 배열의 크기가 1이 되면 재귀 호출을 멈춘다.<br>
입력 데이터 크기 `n`에 대한 알고리즘의 수행 시간을 `T(n)`이라고 하자. 그러면 데이터 크기 n이 1일 때 RecurrenceSum()의 T(n)은 최대 O(1)이 된다. 하지만 n이 1보다 큰 경우에 T(n)은 다음과 같이 정의할 수 있다.(상수 c는 재귀 호출의 비용 외에 알고리즘에서 요구하는 처리 비용을 의미, 위의 예에서는 재귀 호출의 결과와 Data\[0]을 더하는 비용이 해당됨.)<br>
<br>
$T(n) = T(n-1) + c$<br>
<br>
위 식을 펼치면 다음과 같다.<br>
<br>
$T(n)$<br>
 $= T(n-1) + c$<br>
 $= T(n-2) + c + c = T(n-2) + 2c$<br>
 $= T(n-3) + c + c + c = T(n-3) + 3c$<br>
 $= \ldots$<br>
 $= T(2) + (n-2)c$<br>
 $= T(1) + (n-1)c$<br>
 $\leq c + (n-1)c = c + cn - c = cn$<br>
<br>

위 식을 통해 $T(n) \leq cn$을 얻었다. 점근 표기법으로 나타내면 RecurrenceSum() 함수의 수행시간은 $T(n)=O(n)$이 된다.<br>

### 퀵 정렬의 성능 분석
퀵 정렬 함수는 다음과 같다.
```c
void QuickSort ( int DataSet[], int Left, int Right )
{
    if( Left < Right )
    {
        int Index = Partition( DataSet, Left, Right );
        QuickSort( DataSet, Left, Index - 1 );
        QuickSort( DataSet, Index + 1, Right );
    }
}
```
퀵 정렬의 수행시간 = 데이터를 분할하는 데 걸리는 시간 + 데이터를 분할 한 후 2개의 퀵 정렬 재귀 호출에 드는 수행 시간<br>
아래 코드를 보면 Partition() 함수는 데이터 집합의 크기 n만큼 비교를 수행한다. 즉 데이터 집합을 분할하는 데 소요되는 시간은 데이터 집합의 크기에 비례하므로 언제나 `$\Theta$(n)`이다.
```c
int Partition( int DataSet[], int Left, int Right )
{
    int First = Left;
    int Pivot = DataSet[First];

    ++Left;

    while( Left < Right )
    {
        while( DataSet[Left] <= Pivot )
            ++Left;

        while( DataSet[Right] > Pivot )
            --Right;

        if( Left < Right )
            Swap( &DataSet[Left], &DataSet[Right]);
        else
            break;
    }
    Swap( &DataSet[First], &DataSet[Right]);

    return Right;
}
```
퀵 정렬의 성능 분석을 해보면 다음과 같디.<br>
**(1) 최악의 경우**

기준 요소가 데이터 집합에서 가장 작은 값을 가지는 때<br>
이를 재귀 방정식으로 나타내면 다음과 같다.<br>

$T(n)=T(n-1)+cn.\qquad n>1$

이제 n을 1씩 줄여가 보면 아래와 같은 등식을 얻을 수 있다.<br>
$
T(n)=T(n-1)+cn \\\\\\
T(n-1)=T(n-2)+c(n-1) \\\\\\
T(n-2)=T(n-3)+c(n-2) \\\\\\
\cdots \\\\\\
T(3)=T(2)+c(3) \\\\\\
T(2)=T(1)+c(2)
$

위의 등식들은 서로 더해도 여전히 등식은 성립하므로 다 더해보면 아래와 같다.<br>
$
T(n) + T(n-1) + T(n-2) + \cdots + T(2) \\\\\\
= T(n-1) + T(n-2) + T(n-3) + \cdots + T(1) + cn + c(n-1) + c(n-2) + \cdots + c(2)
$

양변에 서로 같은 값을 제거하면 다음의 식을 얻을 수 있다.<br>
$T(n) = T(1) + cn + c(n-1) + \cdots + c(2) = T(1) + c \displaystyle\sum_{i=2}^{n}{i} $

데이터가 하나일 때는 정렬할 것이 없으므로 $T(1)=0$이고, 이를 바탕으로 최악의 경우의 $T(n)$을 점근 표기법으로 나타내면 $O(n^2)$이라 할 수 있다.<br>
$T(1) + c \displaystyle\sum_{i=2}^{n}{i} = O(n^2)$
<br>

**(2) 최선의 경우**
데이터의 분할이 항상 절반으로 이루어지는 경우<br>
QuickSort()가 호출한 Patition() 함수에 의해 데이터가 정확히 반으로 나눠지만, 나눠진 데이터 집합을 각각 2개의 QuickSort() 호출에 매개 변수로 넘긴다. 그러므로 반으로 나눠진 데이터 집합에 대해 2개의 QuickSort()를 호출하는데 소요되는 수행 시간이 $2T\left(\dfrac{n}{2}\right)$, 데이터를 분할하는 데 걸리는 시간이 $cn$(c는 swap() 등 분할하는 데 필요한 부대비용)이므로 이상적인 경우의 퀵 정렬의 수행 시간 $T(n)$은 다음과 같다.<br>
$T(n)=2T\left( \dfrac{n}{2} \right)+cn$


이 식의 양 변을 $n$으로 나누면 다음과 같다.<br>
$\dfrac{T(n)}{n} = \dfrac{2}{n}T\left( \dfrac{n}{2} \right)+c = \dfrac{T(n/2)}{n/2}+c$

그리고 이 식을 2의 제곱수로 나누면 다음과 같은 등식들을 얻을 수 있다.<br>
$
\dfrac{T(n/2)}{n/2}=\dfrac{T(n/4)}{n/4}+c \\\\\\
\dfrac{T(n/4)}{n/4}=\dfrac{T(n/8)}{n/8}+c \\\\\\
\dfrac{T(n/8)}{n/8}=\dfrac{T(n/16)}{n/16}+c \\\\\\
\cdots \\\\\\
\dfrac{T(4)}{4}=\dfrac{T(2)}{2}+c \\\\\\
\dfrac{T(2)}{2}=\dfrac{T(1)}{1}+c
$


2를 $\log_{2}n$번 제곱해야 n이 될 수 있다. 그러므로 $\dfrac{T(n)}{n}$이 $\dfrac{T(2)}{2}$가 되려면 $\log_{2}n$번 나눠야 한다.<br>
$\dfrac{T(n)}{n}$와 $\dfrac{T(n/2)}{(n/2)}$를 더하면 다음과 같다.<br>

$
\dfrac{T(n)}{n} + \dfrac{T(n/2)}{n/2} =  \dfrac{T(n/2)}{n/2} + c + \dfrac{T(n/4)}{n/4} + c \\\\\\
\dfrac{T(n)}{n} = \dfrac{T(n/4)}{n/4} + 2c
$

$\dfrac{T(n)}{n}$와 $\dfrac{T(n/4)}{n/4}$를 더하면 다음과 같다.<br>

$
\dfrac{T(n)}{n} + \dfrac{T(n/4)}{n/4} = \dfrac{T(n/4)}{n/4} + 2c + \dfrac{T(n/8)}{n/8} + c \\\\\\
\dfrac{T(n)}{n} = \dfrac{T(n/8)}{n/8} + 3c
$

이런 식으로 $\dfrac{T(n)}{n}$부터 $\dfrac{T(2)}{2}$를 더하면 다음과 같다.<br>
$\dfrac{T(n)}{n} = \dfrac{T(1)}{1} + c\log_2n$

이 식에 양변에 $n$을 곱하면 $T(n) = cn \log_{2}n + n$ 을 얻을 수 있고 이를 O 표기법으로 나타내면 $O(n\log_{2}n)$이 된다.<br>
<br>

**(3) 평균의 경우**
퀵 정렬은 최악의 경우에 $O(n^2)$, 최선의 경우에 $O(n \log_{2}n)$의 성능을 보인다.<br>
기준 요소가 데이터 집합에서 $i$번째에 있다고 하면, 분할 후에 왼쪽 하위 데이터 집합의 길이는 $i-1$가 되고, 오른쪽 하위 데이터 집합의 길이는 $n-i$가 된다. 이를 통해 퀵 정렬의 평균적 성능을 다음과 같은 재귀 방정식을 통해 얻을 수 있다.<br>
$T(n) = T(i-1) + T(n-i) + cn$

퀵 정렬의 가장 이상적인 경우는 $i$가 $\dfrac{n}{2}$일 때 이고, 최악의 경우는 첫 번째나 $n$번째인 경우이다. 즉 평균의 경우 수행 시간은 최악에서부터 최선까지의 수행 시간을 평균낸 것과 같다.<br>

$T(i) = T(n-i-1) = \dfrac{1}{n} \displaystyle\sum_{i=0}^{n-1}{T(i)}$

따라서 $T(n)$을 다음과 같이 정리할 수 있다.<br>

$T(n) = \dfrac{2}{n} \displaystyle\sum_{i=0}^{n-1}{T(i)} + cn$

시그마 기호($\sum$)를 없애기 위해 양변에 $n$을 곱한다.<br>

$nT(n) = 2 \displaystyle\sum_{i=0}^{n-1}{T(i)} + cn^2$

위 식에서 $n$ 대신 $n-1$을 대입한다.<br>
$(n-1)T(n-1) = 2 \displaystyle\sum_{i=0}^{n-2}{T(i)} + c(n-1)^2$

$nT(n)$에서 $(n-1)T(n-1)$을 빼면 다음과 같이 정리할 수 있다.<br>
$nT(n)-(n-1)T(n-1) = 2T(n-1) + 2cn + c$

$n$이 커질수록, $c$는 상대적으로 무시할 수 있을 만큼 작아지기 때문에 계산의 편의를 위해 $c$를 제거한다.<br>
$nT(n)-(n-1)T(n-1) = 2T(n-1) + 2cn$

위 식을 $nT(n)$에 대해 정리한다.<br>
$
\begin{aligned}
nT(n) &= 2T(n-1) + (n-1)T(n-1) + 2cn \\\\\\
&= (n+1)T(n-1) + 2cn
\end{aligned}
$

이제 위 식을 $T(n)$에 대하여 정리하기 위해 $nT(n)$을 $n(n+1)$로 나눈다.<br>
$\dfrac{T(n)}{n+1} = \dfrac{T(n-1)}{n} - \dfrac{2c}{n+1}$

이 식에 $n$ 대신에 $n-1, n-2, n-3 ... 3, 2$ 까지 대입해본다.<br>

$
\begin{aligned}
\dfrac{T(n-1)}{n} &= \dfrac{T(n-2)}{n-1} - \dfrac{2c}{n} \\\\\\
\dfrac{T(n-2)}{n-1} &= \dfrac{T(n-3)}{n-2} - \dfrac{2c}{n-1} \\\\\\
\cdots \\\\\\
\dfrac{T(3)}{4} &= \dfrac{T(2)}{3} - \dfrac{2c}{4} \\\\\\
\dfrac{T(2)}{3} &= \dfrac{T(1)}{2} - \dfrac{2c}{3}
\end{aligned}
$

$\dfrac{T(n-1)}{n}$ 부터 $\dfrac{T(2)}{3}$까지 더하면 다음 식을 얻을 수 있다.<br>
$\dfrac{T(n)}{n+1} = \dfrac{T(1)}{2} + 2c\displaystyle\sum_{i=3}^{n+1}{\dfrac{1}{i}}$

이 식을 계산해보면 다음과 같이 나온다.<br>

$\dfrac{T(n)}{n+1} = \dfrac{1}{2} + 2c\left[\log_{e}{(n+1)} + 0.5777 - \dfrac{3}{2}\right]$

따라서 $\dfrac{T(n)}{(n+1)}$은 $O(\log n)$이 되며, $T(n)$에 대해 다음과 같이 정리할 수 있다.<br>
$T(n) = O(n\log n)$

<br>

### 마스터 정리
재귀 방정식을 유도한 다음 이를 점근적 표기법으로 나타내는 것은 매우 많은 과정을 거쳐야 한다. 마스터 정리는 이러한 과정 대신 재귀 알고리즘의 성능을 쉽게 파악할 수 있게 해주는 방법이다.<br>

$T(n) = aT\left(\dfrac{n}{b}\right) + f(n)$

예를 들어 위와 같은 재귀 방정식에서 $a \geq 1$, $b > 1$인 상수이고, $f(n)$이 함수일 때 마스터 정리는 위 식의 $T(n)$의 점근적 한계가 아래와 같다고 한다.<br>

1. 어떤 상수 $\varepsilon>0$ 에 대해 $f(n)=O(n^{\log_{b}{a-\varepsilon}})$ 이면, $T(n)=\Theta(n^{\log_{b}{a}})$ 이다.
2. $f(n) = \Theta(n^{\log_{b}{a}})$ 이면, $T(n) = \Theta(n^{\log_ba} log(n))$ 이다.
3. 어떤 상수 $\varepsilon>0$ 에 대해 $f(n) = \Omega(n^{\log_{b}{a + \varepsilon}})$ 이고, 상수 $C(<1)$ 과 충분히 큰 $n$에 대해 $af\left( \dfrac{n}{b} \right) \leq cf(n)$ 이 성립하면, $T(n) = \Theta(f(n))$ 이다.


<br>

**마스터 정리 1**<br>
만약 어떤 상수 $\varepsilon>0$ 에 대해 $f(n)=O(n^{\log_{b}{a-\varepsilon}})$ 이면, $T(n)=\Theta(n^{\log_{b}{a}})$ 이다.<br>
<br>
예를 들어 다음과 같은 재귀 방정식이 있다고 할 때,<br>
$T(n)=5T\left(\dfrac{n}{2}\right)+3n^2$

이 재귀 방정식에서 $a=5, b=2, f(n)=3n^2$ 임을 알 수 있다. 마스터 정리 1에서 $\varepsilon$의 조건은 $\varepsilon > 0$ 인 상수이므로 $\varepsilon$에 대해 $f(n)=O(n^{\log_{b}{a-\varepsilon}})$ 를 만족시키기만 하면 마스터 정리 1을 사용할 수 있다. 그러므로 임의로 $\varepsilon$를 1로 지정한다. 그럼 $f(n) = 3n^2$이므로 $T(n)=\Theta(n^2)$이다.<br>
<br>

**마스터 정리 2**<br>
만약 $f(n) = \Theta(n^{\log_{b}{a}})$ 이면, $T(n) = \Theta(n^{\log_ba} log(n))$ 이다.<br>
<br>
예를 들어 다음과 같은 재귀 방정식이 있다고 할 때,<br>
$T(n) = 2T\left(\dfrac{n}{2}\right)+3n$<br>
이 식으로부터 $a=2, b=2, f(n)=3n$ 임을 알 수 있다. <br>
이 값들이 $f(n) = \Theta(n^{\log_{b}{a}})$ 를 만족시키면 마스터 정리 2를 사용할 수 있다.<br>
$n^{\log_ba} = n^{\log_22}$ 이고, $n^{\log_22} = n^1 = n$ 이다. 따라서 $f(n) = 3n = \Theta(n^{log_ba}) = \Theta(n^1) = \Theta(n)$ 이 성립한다. 그러므로 마스터 정리 2를 사용할 수 있다.<br>
$T(n)$ 을 점근 표기법으로 나타내면 아래와 같다.<br>
$T(n) = \Theta(n^{\log_ba} \log n) = \Theta(n^{\log_22} \log n) = \Theta(n \log n)$<br>
<br>

**마스터 정리 3**<br>
어떤 상수 $\varepsilon>0$ 에 대해 $f(n) = \Omega(n^{\log_{b}{a + \varepsilon}})$ 이고, 상수 $C(<1)$ 과 충분히 큰 $n$에 대해 $af\left( \dfrac{n}{b} \right) \leq cf(n)$ 이 성립하면, $T(n) = \Theta(f(n))$ 이다.<br>
<br>
예를 들어 다음과 같은 재귀 방정식이 있다고 할 때,<br>
$T(n) = 2T\left(\dfrac{n}{2}\right) + n^2$<br>
이 식으로부터 $a=2, b=2, f(n)=n^2$ 임을 알 수 있다. <br>
상수 $\varepsilon$ 를 1이라고 하고 $n^{\log_{b}{a+\varepsilon}}$ 을 구하면 $n^{\log_{b}{a+\varepsilon}} = n^{\log_{2}{2+1}} = n^{1.584962501}$ 이 된다.<br>
따라서 $f(n) = n^2 = \Omega(n^{\log_{b}{a+\varepsilon}}) = \Omega(n^{1.584962501})$ 이 성립한다.<br>
이제 상수 $C(<1>)$ 과 충분히 큰 $n$에 대해 $af\left( \dfrac{n}{b} \right) \leq cf(n)$ 이 성립하는지 확인한다.<br>
$a=2, b=2, f(n)=n^2$ 이다. 충분히 큰 $n$을 100, 1보다 작은 상수 $C$를 $\dfrac{1}{2}$라고 하자<br>
$2f\left(\dfrac{100}{2}\right) \leq \dfrac{1}{2}f(100) $ <br>
$5000 \leq 5000$ <br>
부등식이 성립하므로 위 재귀 방정식은 마스터 정리 3을 사용할 수 있음을 알 수 있다. 이제 $T(n)$을 정리하면 다음과 같다.<br>
$T(n) = \Theta(f(n)) = \Theta(n^2)$
<br>

\# 참고<br>
[박상현 / 뇌를 자극하는 알고리즘](https://www.hanbit.co.kr/media/books/book_view.html?p_code=B3450156021){:target="_blank"}<br>



