---
layout: post
title: "[책/뇌를 자극하는 알고리즘] 4-1. 트리 시작하기"
author: 임가람
date: "2021-08-19 23:17:00"
categories: [책, 뇌를 자극하는 알고리즘]
tags: [뇌를 자극하는 알고리즘]
---

## 트리의 구성 요소
뿌리(Root), 가지(Branch), 잎(Leaf; 단말(Terminal) 노드라고 부르기도 함)
![트리-구조](/assets/img/posts/2021-08-19-tree-1.png){: width="700" height="150" }
<br>

![트리-관계](/assets/img/posts/2021-08-19-tree-2.png){: width="700" height="150" }
위 그림에서 B는 C와 D의 부모(Parent)이고, C와 D는 B의 자식(Children)이다. 그리고 C와 D는 형제(Sibling)이다. B와 K는 아무 관계도 아니다.
<br>

![트리-경로](/assets/img/posts/2021-08-19-tree-3.png){: width="700" height="150" }
트리에서 경로(Path)는 한 노드에서 다른 노드까지 이르는 길 사이에 놓여있는 노드들의 순서이다. 예를 들어 위 그림에서 B 노드에서 F 노드를 찾아간다고 할 때, B 노드에서 출발해서 D 노드를 방문하고, D 노드에서 출발하여 F 노드에 도착한다. 이 예시에서 “B, D, F”를 B에서 F까지의 경로라고 하고, 길이(Length)는 2이다.
<br>

![트리-깊이](/assets/img/posts/2021-08-19-tree-4.png){: width="700" height="150" }
깊이(Depth)는 루트 노드에서 해당 노드까지의 경로의 길이를 뜻한다.<br>
레벨(Level)은 깊이가 같은 노드의 집합을 말한다. 위 그림에서 ‘레벨 2’는 ‘C, D, H, J’ 노드를 지칭한다.<br>
높이(Height)는 가장 깊은 곳에 있는 잎 노드까지의 깊이를 뜻한다. 위 그림에서 트리의 높이는 3이다.
<br>

![트리-차수](/assets/img/posts/2021-08-19-tree-5.png){: width="700" height="150" }
노드의 차수(Degree)는 그 노드의 자식 노드 개수를 말하고, 트리의 차수는 트리 내에 있는 노드들 가운데 자식 노드가 가장 많은 노드의 차수를 말한다. 위 그림에서 트리의 차수는 3이다.
<br>

---
## 트리 표현하기
### 중첩된 괄호(Nested Parenthesis) 표현법
![트리-중첩된괄호표현법](/assets/img/posts/2021-08-19-tree-6.png){: width="700" height="150" }
<br>

### 중첩된 집합(Nested Set) 표현법
![트리-중첩된집합표현법](/assets/img/posts/2021-08-19-tree-7.png){: width="700" height="150" }
<br>

### 들여쓰기(Indentation) 표현법
![트리-들여쓰기표현법](/assets/img/posts/2021-08-19-tree-8.png){: width="700" height="150" }
<br>

---
## 노드 표현하기
### N-링크(N-Link) 표현법
노드의 차수가 N이라면, 노드가 N개의 링크를 가지고 있어서 링크들이 각각 자식 노드를 가리키도록 구성하는 방법
![트리-N-Link표현법](/assets/img/posts/2021-08-19-tree-9.png){: width="700" height="150" }
이 표현법은 차수(자식 노드의 수)가 노드마다 달라지는 트리에는 적용하기 어려운 단점이 있다.<br>
<br>

### 왼쪽 자식-오른쪽 형제(Left Child-Right Sibling) 표현법
N개의 차수를 가진 노드의 표현을 통해 N-링크의 단점을 두 개의 포인터로 해결된다.
![트리-LCRS표현법](/assets/img/posts/2021-08-19-tree-10.png){: width="700" height="150" }
어느 한 노드의 모든 자식 노드를 얻으려면 왼쪽 자식 노드에 대한 포인터를 통해 왼쪽 자식 노드의 주소를 얻은 후, 이 자식의 오른쪽 형제 노드의 주소를 얻어나가면 모든 자식 노드를 얻을 수 있다.
<br>

---
## 트리 구현하기
### 노드의 선언
Data(데이터 보관), LeftChild(왼쪽 자식), RightSibling(오른쪽 형제)
<br>

### 노드의 생성과 소멸
생성: 구조체의 크기 만큼 자유 저장소에 할당, 매개 변수 NewData를 Data에 저장한 뒤, 그 주소를 반환
소멸: 노드를 자유 저장소에서 해제
<br>

### 자식 노드 연결하기
부모 노드인 Parent에 자식 노드가 있는지 확인한다.<br>
Parent의 LeftChild가 NULL이면 LeftChild 포인터에 Child가 가리키고 있는 주소값을 저장한다.<br>
Parent의 LeftChild가 NULL이 아니면 자식 노드의 RightSibling 포인터를 이용해서 가장 오른쪽에 있는 자식 노드를 찾고, 그 자식 노드의 RightSibling에 Child를 대입한다.
<br>

### 소스코드
트리를 들여쓰기 형태로 표현하기 위해 for 루프에서 입력된 Depth만큼 공백(Space)을 출력한다. Depth를 다 출력한 후 노드의 데이터를 출력한다.
<br>

LCRSTree.h
```c
#ifndef LCRS_TREE_H
#define LCRS_TREE_H

#include <stdio.h>
#include <stdlib.h>

typedef char ElementType;

typedef struct tagLCRSNode 
{
    struct tagLCRSNode* LeftChild;
    struct tagLCRSNode* RightSibling;

    ElementType Data;
} LCRSNode;


LCRSNode* LCRS_CreateNode( ElementType NewData );
void      LCRS_DestroyNode( LCRSNode* Node );
void      LCRS_DestroyTree( LCRSNode* Root );

void      LCRS_AddChildNode( LCRSNode* ParentNode, LCRSNode *ChildNode);
void      LCRS_PrintTree( LCRSNode* Node, int Depth );

#endif LCRS_TREE_H
```

LCRSTree.c
```c
#include "LCRSTree.h"

LCRSNode* LCRS_CreateNode( ElementType NewData )
{
    LCRSNode* NewNode = (LCRSNode*)malloc( sizeof(LCRSNode) );
    NewNode->LeftChild    = NULL;
    NewNode->RightSibling = NULL;
    NewNode->Data = NewData;

    return NewNode;
}

void LCRS_DestroyNode( LCRSNode* Node )
{
    free(Node);
}

void LCRS_DestroyTree( LCRSNode* Root )
{
    if ( Root->RightSibling != NULL )
        LCRS_DestroyTree( Root->RightSibling );

    if ( Root->LeftChild != NULL )
        LCRS_DestroyTree( Root->LeftChild );

    Root->LeftChild = NULL;
    Root->RightSibling = NULL;

    LCRS_DestroyNode( Root );
}

void LCRS_AddChildNode( LCRSNode* Parent, LCRSNode *Child)
{
    if ( Parent->LeftChild == NULL )
    {
        Parent->LeftChild = Child;
    }
    else 
    {
        LCRSNode* TempNode = Parent->LeftChild;
        while ( TempNode->RightSibling != NULL )
            TempNode = TempNode->RightSibling;

        TempNode->RightSibling = Child;        
    }
}

void LCRS_PrintTree( LCRSNode* Node, int Depth )
{
    int i=0;
    /* 깊이 만큼 들여쓰기를 한다. */ 
    for ( i=0; i<Depth; i++ )
        printf(" ");
    /* 노드에 담긴 데이터를 출력한다. */
    printf("%c\n", Node->Data);

    if ( Node->LeftChild != NULL )
        LCRS_PrintTree(Node->LeftChild, Depth+1);

    if ( Node->RightSibling != NULL )
        LCRS_PrintTree(Node->RightSibling, Depth);
}
```
Test_LCRSTree.c
```c
#include "LCRSTree.h"

int main( void )
{
    /*  노드 생성 */
    LCRSNode* Root = LCRS_CreateNode('A');
    
    LCRSNode* B = LCRS_CreateNode('B');
    LCRSNode* C = LCRS_CreateNode('C');
    LCRSNode* D = LCRS_CreateNode('D');
    LCRSNode* E = LCRS_CreateNode('E');
    LCRSNode* F = LCRS_CreateNode('F');
    LCRSNode* G = LCRS_CreateNode('G');
    LCRSNode* H = LCRS_CreateNode('H');
    LCRSNode* I = LCRS_CreateNode('I');
    LCRSNode* J = LCRS_CreateNode('J');
    LCRSNode* K = LCRS_CreateNode('K');

    /*  트리에 노드 추가 */
    LCRS_AddChildNode( Root, B );
        LCRS_AddChildNode( B, C );
        LCRS_AddChildNode( B, D );
            LCRS_AddChildNode( D, E );
            LCRS_AddChildNode( D, F );

    LCRS_AddChildNode( Root, G );
        LCRS_AddChildNode( G, H );

    LCRS_AddChildNode( Root, I );
        LCRS_AddChildNode( I, J );
            LCRS_AddChildNode( J, K );
    
    /*  트리 출력 */
    LCRS_PrintTree( Root, 0 );

    /*  트리 소멸시키기 */
    LCRS_DestroyTree( Root );

    return 0;
} #include "LCRSTree.h"

int main( void )
{
    /*  노드 생성 */
    LCRSNode* Root = LCRS_CreateNode('A');
    
    LCRSNode* B = LCRS_CreateNode('B');
    LCRSNode* C = LCRS_CreateNode('C');
    LCRSNode* D = LCRS_CreateNode('D');
    LCRSNode* E = LCRS_CreateNode('E');
    LCRSNode* F = LCRS_CreateNode('F');
    LCRSNode* G = LCRS_CreateNode('G');
    LCRSNode* H = LCRS_CreateNode('H');
    LCRSNode* I = LCRS_CreateNode('I');
    LCRSNode* J = LCRS_CreateNode('J');
    LCRSNode* K = LCRS_CreateNode('K');

    /*  트리에 노드 추가 */
    LCRS_AddChildNode( Root, B );
        LCRS_AddChildNode( B, C );
        LCRS_AddChildNode( B, D );
            LCRS_AddChildNode( D, E );
            LCRS_AddChildNode( D, F );

    LCRS_AddChildNode( Root, G );
        LCRS_AddChildNode( G, H );

    LCRS_AddChildNode( Root, I );
        LCRS_AddChildNode( I, J );
            LCRS_AddChildNode( J, K );
    
    /*  트리 출력 */
    LCRS_PrintTree( Root, 0 );

    /*  트리 소멸시키기 */
    LCRS_DestroyTree( Root );

    return 0;
}
```
실행결과
```
A
 B
  C
  D
   E
   F
 G
  H
 I
  J
   K
```

<br>

\# 참고<br>
[박상현 / 뇌를 자극하는 알고리즘](https://www.hanbit.co.kr/media/books/book_view.html?p_code=B3450156021){:target="_blank"}<br>