---
layout: post
title:  "RXJava"
date:   2019-12-10 00:14:27 +0900
categories: rxjava
---

### Netflix에서 RXJava를 만들게 된 이유
-----
<br>

#### 1. 동시성 수용(Embrace Concurrency)
네트워크 통신을 효과적으로 줄이기 위해서는 서버측 동시성이 필요하다.<br>
RXJava는 클라이언트의 요청을 처리할 때 **다수의 비동기 스레드를 생성하고 그 결과를 취합하여 최종 리턴**하는 방식으로 진행된다.
<br><br>

#### 2. Java Future를 조합하기 어렵다(Java Futures are Expensive to Compose)
> Java Future<br><br>
실행 결과를 얻기까지 시간이 걸리는 메소드가 있다고 했을 때 실행 결과를 얻기까지 기다리는 대신 "교환권"을 받게 되는데 그 교환권을 Future라고 한다.<br><br>
Future를 받은 쓰레드는 나중에 Future를 사용해서 실행 결과를 받으러 간다.<br><br>
만약 실행 결과가 나와 있으면 바로 그것을 받고, 그렇지 않으면 준비가 될 때 까지 기다린다.

Java 8 에서 CompletableFuture 같은 클래스를 제공하지 않았기 때문에 **비동기 흐름을 조합할 수 있는 방법**이 필요해서 제작했다.
<br><br>

#### 3. 콜백 방식의 문제점 개선(Callbacks Have Their Own Problems)
콜백(Callback; 시스템이 필요한 시점에 호출하는 이벤트)안에서 또 다른 콜백을 부르는 코딩 방식은 코드의 가독성을 떨어뜨리고 오류 발생시 디버깅이 어렵다는 단점이 있다. 이를 개선하기 위해 RXJava를 제작했다.
<br><br>

### RXJava를 시작하기 전에 알아야 할 것들
-----
<br>

#### 1. Observer Pattern
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 신호가 가고, 신호를 받은 다른 객체들의 내용을 자동으로 갱신하는 일대다 패턴<br><br>
Observer: 하나 이상의 객체를 관찰 대상으로 등록함<br>
Subject: 관찰 대상<br>
![img1](/img/2019-12-10-rxjava-1.png)
<br><br>

#### 2. 람다 표현식
기존의 자바는 클래스를 작성하고 객체를 생성(new)해야 해당 클래스의 메소드를 사용할 수 있는데<br>
람다 표현식은 객체를 생성하지 않아도 메소드를 사용할 수 있다.<br>
<br><br>
큰 수 찾기 예제
```java
// 기존
int max(int a, int b) {
    return a > b ? a : b;
}
```
```java
// 람다표현식
(a, b) -> a > b ? a : b
```
<br>
Thread 예제
```java
// 기존
new Thread(new Runnable() {
    public void run() {
        System.out.println("기존 쓰레드 생성 방식");
    }
}).start();
```
```java
// 람다표현식
new Thread(() -> {
    System.out.println("람다 표현식을 사용한 쓰레드 생성 방식");
}).starT();
```
<br>
<br>

#### 3. Method Reference
구현하고자 하는 람다식 자체가 구현되어 있는 경우 해당 메소드 참조하여 쓰는것을 Method Reference라고 한다.
<br>
리스트 출력 예제
```java
// 기존
String [] strings = new String [] {
    "6", "5", "4", "3", "2", "1"
};
List<String> list = Arrays.asList(strings);
for(String s : strings)
    System.out.println(s);
```
```java
// Method Reference
String [] strings = new String [] {
    "6", "5", "4", "3", "2", "1"
};
List<String> list = Arrays.asList(strings);
list.forEach(x -> System.out.println(x));
```
<br>
<br>




출처:<br>
&nbsp;&nbsp;[Netflix 기술블로그]<br>
&nbsp;&nbsp;[나무위키]<br>

[Netflix 기술블로그]: https://medium.com/netflix-techblog/reactive-programming-in-the-netflix-api-with-rxjava-7811c3a1496a
[나무위키]: https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4


<!-- ~~Oh My God~~
`_posts` -->