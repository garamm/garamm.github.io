---
layout: post
title: "[책/뇌를 자극하는 알고리즘] 14. 탐욕 알고리즘"
author: 임가람
date: "2021-09-25 16:34:00"
categories: [책, 뇌를 자극하는 알고리즘]
tags: [뇌를 자극하는 알고리즘]
---

## 탐욕(Greedy) 알고리즘에 대하여
동적 계획법과 마찬가지로 최적화 문제의 답을 얻기 위해 사용한다. 탐욕 알고리즘은 각 단계의 부분 문제를 풀 때마다 근시안(그 순간의 최선의 선택 함)적으로 최적해를 구하는 알고리즘이다.<br>
동적 계획법은 최적의 해를 구하긴 하지만 탐욕 알고리즘보다는 덜 효율적(대게 더 많은 수행 시간을 요구)이다. 탐욕 알고리즘은 동적 계획법보다 효율적이긴 하지만 동적 계획법처럼 반드시 최적의 해를 구해준다는 보장은 하지 못한다.<br>
탐욕 알고리즘으로 풀 수 있는 문제는 동적 계획법처럼 대상 문제가 최적 부분 구조를 갖고 있어야 한다.<br>
탐욕 알고리즘은 다음과 같은 과정으로 동작한다.<br>
1. 해 선택: 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2. 실행 가능성 검사: 새로운 부분해 집합이 실행가능한지를 확인한다. 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1번의 해 선택부터 다시 시작한다.

<br>

---
## 편의점 점원의 거스름돈 줄이기
예를 들어 물건의 가격이 1,200원이고 손님이 1,000원 지폐 두 개를 지불하면 거스름돈 800원을 손님께 내드려야 한다. 이때 거스름돈을 100원짜리 8개로 내드릴 수도 있지만, 동전의 개수를 최소한으로 하려면 500원짜리 한 개와 백 원까리 세 개를 내드려야 한다.<br>
거스름돈의 개수를 최소한으로 내어주는 문제를 탐욕 알고리즘에 따라 풀이하면 다음과 같다.<br>
1. 해 선택: 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.
2. 실행 가능성 검사: 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1번으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.
3. 해 검사: 거스름돈을 확인해서 모자라면 다시 1번으로 돌아가서 거스름돈에 추가할 동전을 고른다.

<br>

### 거스름돈 계산 프로그램
MakingChange.h
```c
void GetChange( int Price, int Pay, int CoinUnits[], int Change[], int Size );
int  CountCoins( int Amount, int CoinUnit);
void PrintChange( int CoinUnits[], int Change[], int Size );
```
MakingChange.c
```c
#include "MakingChange.h"
#include <stdio.h>

void GetChange( int Price, int Pay, int CoinUnits[], int Change[], int Size )
{
    int i=0;
    int ChangeAmount = Pay - Price;
        
    for ( i=0; i<Size; i++ ) /* 해 검사: 큰 단위의 동전부터 작은 단위의 동전까지 필요한 개수를 세면 거스름돈이 완성됨 */
    {
        /* 해 선택: 현 단계에서 가능한 큰 단위의 동전을 고름 */
        Change[i]    = CountCoins( ChangeAmount, CoinUnits[i] );
        ChangeAmount = ChangeAmount - ( CoinUnits[i] * Change[i] );
    }
}

int CountCoins( int Amount, int CoinUnit)
{
    int CoinCount     = 0;
    int CurrentAmount = Amount;

    while ( CurrentAmount >= CoinUnit )
    {
        CoinCount++;
        CurrentAmount = CurrentAmount - CoinUnit;
    }

    return CoinCount;
}

void PrintChange( int CoinUnits[], int Change[], int Size )
{
    int i=0;

    for ( i=0; i<Size; i++ )
        printf( "%8d원 : %d개\n", CoinUnits[i], Change[i] );        
}
```
TestMakingChange.c
```c
#include "MakingChange.h"
#include <stdio.h>
#include <stdlib.h>

int Compare( const void* a, const void* b ) 
{ 
    int _a = *(int*)a;
    int _b = *(int*)b;

    if ( _a < _b)
        return 1;
    else 
        return -1;
} 

int main( void )
{
    int  i     = 0;
    int  Pay   = 0 ;
    int  Price = 0;
    int  UnitCount = 0;
    int* CoinUnits = NULL;
    int* Change    = NULL;
    
    printf("동전의 가짓수를 입력하세요 :"); 
    scanf( "%d", &UnitCount );

    CoinUnits = (int*) malloc( sizeof(int) * UnitCount );
    Change    = (int*) malloc( sizeof(int) * UnitCount );

    for ( i=0; i<UnitCount; i++ )
    {
        printf("[%d] 번째 동전의 단위를 입력하세요 : ", i );
        scanf( "%d", &CoinUnits[i] );
    }

    qsort( CoinUnits, UnitCount, sizeof(int), Compare );

    printf("물건 가격을 입력하세요 : ");
    scanf( "%d", &Price );

    printf("손님이 지불한 돈은 얼마입니까? : ");
    scanf( "%d", &Pay );

    GetChange( Price, Pay, CoinUnits, Change, UnitCount );
    
    PrintChange( CoinUnits, Change, UnitCount);

    return 0;
}
```
실행결과
```
동전의 가짓수를 입력하세요 : 5
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 100
[2] 번째 동전의 단위를 입력하세요 : 50
[3] 번째 동전의 단위를 입력하세요 : 10
[4] 번째 동전의 단위를 입력하세요 : 1
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
    500원 : 1개
    100원 : 3개
     50원 : 0개
     10원 : 0개
      1원 : 0개
```
<br>

### 거스름돈을 만드는 탐욕 알고리즘은 항상 최적일까?
대부분의 국가에서 사용하는 지폐/동전들의 단위는 탐욕 알고리즘이 항상 최적의 거스름돈을 만들 수 있게 되어있다. 우리나라 동전은 500원, 100원, 50원, 10원, 1원 이렇게 5개가 있는데 이 다섯 가지 중 어느 두 개를 골라 두 동전 사이의 최대 공약수를 계산해도 항상 작은 값의 동전 단위가 나온다.<br>
그런데 만약 400원짜리 동전을 새로 발행한다면 800원의 거스름돈의 최적해는 위의 실행 결과와 다르게 400원 2개가 된다.<br>
즉 탐욕 알고리즘은 항상 최적이지는 않다.
<br>

---
## 크루스칼의 최소 신장 트리 알고리즘 다시 보기
[최소 신장 트리](/posts/graph-minimum-spanning-tree){:target="_blank"} 는 다음과 같은 그래프가 있다고 했을 때, 그래프 내의 정점을 최소의 비용으로 연결하는 트리를 말한다.<br>
![최소 신장 트리 1](/assets/img/posts/2021-09-25-greedy-1.png){: width="700" height="150" }

최소 신장 트리를 만들기 위해 사용하는 크루스칼 알고리즘은 아래와 같이 동작한다.<br>
1. 그래프 내의 모든 간선을 가중치의 오름차순으로 목록을 만든다.
2. 1번에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가한다. 단, 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안된다.

여기서 2번 단계를 탐욕 알고리즘으로 처리된다. 간선의 목록을 돌면서 최소 신장 트리를 완성해 나가는 부분이 '해 선택 - 실행 가능성 검사 - 해 검사'의 반복으로 이루어진다.<br>
해 선택은 가장 작은 가중치의 간선을 고르면서 이루어진다.<br>
크루스칼 알고리즘에서 중요한 것은 실행 가능성 검사이다. 해 선택 단계에서 고른 간선이 신장 트리 내에 사이클을 형성한다면, 이 간선을 버리고 다음 가중치의 간선을 골라야 한다. 크루스칼 알고리즘은 사이클 탐지를 위해 분리 집합을 이용한다. 간선을 추가할 때마다 간선의 양 끝에 있는 정점들을 같은 집합에 추가시키는데, 이 두개의 정점이 이미 같은 집합에 소속되어 있다면 이 간선이 사이클을 형성한다고 판단한다.<br>
다음 그림은 이미 가중치의 오름차순으로 A-B, E-F, E-H, G-I, C-D 간선이 연결되었고, 이제 F-H(가중치 120)을 추가하려고 한다. 그런게 정점 F와 H는 이미 같은 집합에 속해있기 때문에 F-H 간선을 연결하게 되면 사이클이 형성되므로 F-H는 실행 가능성 검사에서 거부당한다.<br>
![최소 신장 트리 2](/assets/img/posts/2021-09-25-greedy-2.png){: width="700" height="150" }

그래서 다시 해 선택 단계로 넘어간다. 이번에는 가중치가 126인 간선 B-C를 선택한다. 실행 가능성 검사를 해보면 B-C 끝에 여결되어 있는 정점 B와 C는 서로 다른 집합의 원소이므로 사이클을 생성하지 않는다. 그러므로 실행 가능성 검사에 통과한다.<br>
![최소 신장 트리 3](/assets/img/posts/2021-09-25-greedy-3.png){: width="700" height="150" }

크루스칼 알고리즘은 모든 정점들이 하나의 집합에 들어 있으면 해가 완성된다.<br>
<br>

---
## 다익스트라의 최단 경로 알고리즘 다시 보기
[다익스트라의 최단 경로 알고리즘](/posts/graph-dijkstra/){:target="_blank"} 은 그래프 내의 한 정점에서 다른 정점으로 향하는 가장 짧은 경로를 구하는 알고리즘이다.<br>
다익스트라 알고리즘은 다음과 같이 동작한다.<br>

1. 각 정점 위에 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 준비하고 모든 정점 위에 있는 경로의 길이를 $\infty$(무한대)로 초기화한다.
2. 시작 정점의 경로 길이를 0으로 초기화하고(시작 정점에서 시작 정점까지의 길이는 0이기 때문) 최단 경로에 추가한다.
3. 최단 경로에 새로 추가된 정점의 인접 정점들에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가한다. 만약 추가하려는 인접 정점이 이미 최단 경로 안에 존재한다면 갱신되기 이전의 경로 길이가 새로운 경로의 길이보다 더 큰 경우에 한해, 다른 선행 정점을 지나던 기존의 경로를 현재 정점을 경유하도록 수정한다.
4. 그래프 내의 모든 정점이 최단 경로에 소속될 때까지 3번 과정을 반복한다.

여기서 1, 2번은 알고리즘의 초기화 작업에 해당하고, 3번은 해 선택과 실행 가능성 검사, 4번은 해 검사에 해당한다.<br>
이 알고리즘에서는 최단경로가 해 집합이고, 각 정점이 부분 문제에 대한 해이다.<br>
우선 1, 2 단계를 수행한다.<br>
![다익스트라 1](/assets/img/posts/2021-09-25-greedy-4.png){: width="700" height="150" }

현재 시점에서 가장 마지막에 추가한 정점은 시작 정점 B이다. 시작 정점 B에 인접한 정점 A, C, F를 최단 경로에 추가하고, 각 정점에 이르는 데 소요되는 비용을 기록한다.<br>
B-A는 35, B-C는 126, B-F는 150이다. 이미 최단 경로 안에 들어 있는 정점들은 없으므로 실행 가능성 검사를 통과한다. 아직 최단 경로를 완성하지 못했으므로 4번의 해 검사는 통과하지 못한다. 그러므로 3번을 반복한다.<br>
![다익스트라 2](/assets/img/posts/2021-09-25-greedy-5.png){: width="700" height="150" }

앞 단계에서 정점 3개가 최단 경로에 새로 추가됐다. 이 정점들에 대해 다시 3번의 과정을 적용한다. 먼저 A의 인접 정점은 E 하나이다. E를 최단 경로에 추가하고, E에 이르는 비용 282를 기록한다. 실행 가능성 검사는 통과하고, 해 검사는 통과하지 못하므로 계속해서 정점 C를 처리한다.<br>
![다익스트라 3](/assets/img/posts/2021-09-25-greedy-6.png){: width="700" height="150" }

C의 인접 정점은 D, F, G가 있는데 현재 D의 경로 길이는 무한대이므로 B-C-D 경로의 비용을 그대로 입력하고, G도 경로 길이가 무한대이므로 B-C-G 경로의 비용을 입력하면 된다.<br>
D와 G는 둘 다 실행 가능성 검사를 통과한다. F는 이미 최단 경로 안에 포함되어 있고, 포함되어 있는 경로 B-F의 비용은 150으로 새로 추가하려는 B-C-의 비용 280보다 작기 때문에 탈락이다.<br>
F는 실행 가능성 검사를 통과하지 못했기 때문에 다음 단계로 넘어간다.<br>
![다익스트라 4](/assets/img/posts/2021-09-25-greedy-7.png){: width="700" height="150" }

이 알고리즘은 한 정점의 인접 정점들에 대한 정보만 이용해서 최단 경로를 구축하기 때문에 다익스트라 알고리즘도 탐욕 알고리즘을 이용해서 문제를 해결함을 알 수 있다.<br>
<br>

---
## 허프만 코딩을 이용한 데이터 압축
### 고정 길이 코드(Fixed Length Code)와 접두어 코드(Prefix Code)
고정 길이 코드는 모든 코드의 길이가 똑같은 값을 갖는 코드 체계를 말한다. (예. ASCII 코드) 다루기 쉽다는 장점이 있다.<br>
예를 들어 비트로 표시된 ASCII 코드 문자열 01100001011000100110001101100100은 어떤 문자료 구성되어있는지 알기 위해서 이 문자열을 8bit씩 나누고, 각 조각과 코드 집합에 정의되어 있는 값을 비교하여 찾아서 표기하면 된다.<br>

|ASCII(이진수)|01100001|01100010|01100011|01100100|
|---|---|---|---|---|
|ASCII(십진수)|97|98|99|100|
|ASCII 기호|a|b|c|d|

이렇게 해서 01100001011000100110001101100100는 'abcd'임을 알 수 있다.<br>
고정 길이 코드가 연산의 편의를 위한 것이라면, 가변 길이 코드(Variable Length Code)는 저장 공간의 절약을 위한 것이다. 저장 공간의 절약을 아껴주기는 하지만 데이터의 처리는 번거롭다는 단점이 있다.<br>
접두어 코드는 가변 길이 코드의 한 종류이다. 접두어 코드는 무(無)접두어 코드(Prefix Free Code)라고 불리기도 한다. 접두어 코드는 코드 집합의 어느 코드도 다른 코드의 접두어가 되지 않는 코드를 말한다(이것을 접두어 속성(Prefix Property)이라고 함). 예를 들어 코드 집합 {"0", "1", "01", "010"}은 "0"이 "01"과 "010"의 접두어가 되기 때문에 접두어 코드가 아니다. 반면에 {"00", "010", "100", "101"}은 어느 코드도 다른 코드의 접두어가 되지 않기 때문에 접두어 코드이다.<br>
예를 들어 a, b, c, d를 나타내는 접두어 코드가 다음과 같이 정의되어 있다고 하자<br>
```
a = 00
b = 010
c = 100
d - 101
```
위 코드대로라면 'abcd'는 00010100101로 표현할 수 있다. ASCII로는 32bit가 필요한데, 접두어 코드로 표현하면 11bit만 있으면 된다.<br>
ASCII와 같은 고정 길이 코드로 이루어진 데이터를 접두어 코드로 변환/해제할 수 있는 메커니즘이 있으면 데이터를 압축/해제할 수 있는데 이를 기반한 것이 허프만 코딩이다.<br>
<br>

### 허프만 트리 만들기
허프만 코딩 알고리즘을 이해하기 위해서는 `기호의 빈도`와 `이진 트리`를 기억하면 된다.<br>
기호의 빈도는 한 기호가 데이터 안에서 차지하는 비율을 말한다. 'Programing'이라는 문자열을 예로 들어보면, 길이는 11이고, 기호 'g', 'm', 'r'의 빈도는 2이고 'P', 'o', 'i'의 빈도는 1이다.<br>
빈도가 높은 기호에 작은 접두어 코드를 부여하면 그만큼 저장 공간을 아낄 수 있기 때문에(= 압축률이 높아진다) 길이가 짧은 접두어 코드를 빈도가 높은 기호에 부여하는데 기호의 빈도를 사용한다.<br>
예를 들어 어떤 문자열이 'a' 기호 20개와 'b' 기호 5개로 이루어진다고 하고 'a'에 코드 100을, 'b'에 코드 11을 부여하면 변환된 데이터의 크기는 3(100의 비트 수) $\times$ 200 $+$ 2(11의 비트 수) $\times$ 5 = 70 비트가 된다. 원본 문자열이 200 비트였으니 원본 크기 대비 35%로 압축된다. 하지만 'a'에 코드 11, 'b'에 코드 100을 부여하면 2(11의 비트 수) $\times$ 20 + 3(100의 비트 수) $\times$ 5 = 55로 앞의 방법에 비해 15비트를 더 절약할 수 있다.<br>
이진 트리는 접두어 코드를 표현하는 데 사용한다. 트리의 노드에서 왼쪽 자식 노드는 0, 오른쪽 자식 노드는 1을 나타낸다. 이 트리에서 모든 기호는 잎 노드에만 기록되어 있는데, 루트 노드에서부터 잎 노드까지 이르는 경로가 기호의 접두어 코드가 된다. 이렇게 접두어 코드를 표현하는 이진 트리를 허프만 트리(Huffman Tree)라고 한다.<br>
![허프만트리 1](/assets/img/posts/2021-09-25-greedy-8.png){: width="700" height="150" }

위 트리를 보면 잎 노드는 총 4개이다. 이 노드들에 저장되어 있는 기호는 a, b, c, d이다. 루트 노드로부터 a 노드까지 이르는 경로는 0 하나이다. 즉 a의 접두어 코드는 0이 된다.<br>
루트 보드로부터 b 노드까지 이르는 경로에는 오른쪽(1), 왼쪽(0), 왼쪽(0) 노드이므로 100이 된다.<br>
이 트리의 루트 노드에서 잎 노드에 이르는 경로가 길어질수록 접두어 코드도 길어진다. 빈도가 높은 기호일수록 경로를 짧게, 빈호가 낮은 기호일수록 경로를 길게 가져가야 압축률이 높아진다.<br>
예를 들어 'aaabaacdd'라는 문자열이 있다고 가정하면 a의 빈호는 5이고, b, c의 빈도는 1, 그리고 d는 2이다. 이 기호들을 빈도와 함께 다음 그림과 같이 트리의 노드를 생성한다.<br>
![허프만트리 2](/assets/img/posts/2021-09-25-greedy-9.png){: width="700" height="150" }

허프만 트리에서 기호는 잎 노드에만 저장되므로, 이 노드들은 끝까지 잎 노드로 남아야 한다. 그러므로 이 노드들 위에 부모 노드를 만들어 연결시켜 나가면서 트리를 완성해야 한다. 탐욕 알고리즘의 과정을 따라 트리를 완성해보자.<br>
우선 해를 선택해야 한다. 현 시점에서 빈도가 가장 작은 노드는 b, c두 개이다. 이 두 노드 위에 부모 노드를 새로 만들어 이 두 노드를 왼쪽과 오른쪽에 연결시킨다. 이때 부모 노드의 빈도는 자식 노드들의 빈호의 합이 되며 기호는 따로 갖지 않는다. 마지막으로 새로 만든 부모 노드를 노드 집합에 추가한다.<br>
이제 실행 가능성 검사를 해봐야 한다. 기호를 가진 노드는 잎 노드여야 하므로 현재는 실행 가능성 검사를 통과한다. 그 다음 해 검사를 하는데 아직 허프만 트리를 완성하지 못했으므로 해 검사는 통과하지 못한다. 그러므로 다시 해 선택 단계로 돌아간다. <br>
![허프만트리 3](/assets/img/posts/2021-09-25-greedy-10.png){: width="700" height="150" }


현재 상태에서는 이전 단계에서 새로 만든 노드(b, c의 무보 노드)와 d 노드의 빈도가 가장 작으므로 이 두 노드를 선택한다. 부모 노드를 새로 만들고 b, c의 부모 노드와 d 노드를 자식 노드로 연결시킨다. 실행 가능성 검사는 통과하지만 해 검사는 통과하지 못했으므로 다시 해 선택 단계로 돌아간다.<br>
![허프만트리 4](/assets/img/posts/2021-09-25-greedy-11.png){: width="700" height="150" }


빈도가 가장 작은 두 개의 노드를 골라야 하는데 잔여 노드가 딱 두 개 이다. 새 노드를 만들고 여기에 노드 a와 c, d의 루트 노드를 자식 노드로 연결한다. 모든 기호 노드가 잎 노드이기 때문에 실행 가능성 검사는 통과이고, 새로운 노드를 노드 집합에 추가한다.<br>
![허프만트리 5](/assets/img/posts/2021-09-25-greedy-12.png){: width="700" height="150" }


이제 노드 집합에는 단 하나의 노드만 남아있다. 즉 접두어 트리가 완성되었다. 이제 이 집합에서 남아 있는 노드를 꺼내면 이 노드가 곧 허프만 트리가 된다.<br>
![허프만트리 6](/assets/img/posts/2021-09-25-greedy-13.png){: width="700" height="150" }


<br>

### 데이터 압축하기
압축은 문자열의 각 요소를 차례대로 읽으면서 허프만 트리가 나타내는 해당 문자의 접두어 코드로 변환하면 된다.<br>

|a|a|a|b|a|a|c|d|d|
|---|---|---|---|---|---|---|---|---|
|0|0|0|100|0|0|101|11|11|

'aaabaacdd'의 압축 결과는 '000100001011111'로써, 원본 데이터(ASCII 코드)의 크기 72비트에서 15비트로 압축됐다.<br>

참고)<br>
앞의 허프만 트리에서 a의 접두어 코드를 알아내려면 a를 찾아내야 하는데, 그러면 모든 잎 노드를 조사하는 수밖에 없다. 이 문제를 해결하기 위해서는 별도의 심볼 : 접두어 코드 테이블을 만들어 놓고 접두어 코드를 알고 싶으면 이 테이블을 이용하게끔 만들면 된다.<br>

<br>

### 압축 해제하기
허프만 코디으이 압출을 해제하는 방법은 다음과 같다.<br>
1. 압축을 위해 만들었던 허프만 트리와 압축 해제된 데이터를 담을 버퍼를 준비한다. 허프만 트리의 루트 노드로부터 시작해서 잎 노드까지 순회한다.
2. 압축 데이터에 의해 아직 읽지 않은 부분이 남아 있으면 데이터를 한 비트 읽는다.
3. 읽어낸 비트가 0이면 현재 노드의 읜쪽 자식 노드, 1이면 오른쪽 자식 노드로 이동한다. 현재 노드가 잎 노드이면 저장되어 있는 기호를 버퍼에 추가하고 다시 루트 노드로 이동한다.

위 3 단계를 요약하면 비트를 읽을 때마다 잎 노드를 만나기 전까지 허프만 트리의 왼쪽/오른쪽으로 노드를 순회하라는 뜻이다.<br>
이번 예제는 앞 절에서 데이터 압축 결과 '000100001011111'을 해제해본다.<br>
먼저 아래 그림처럼 허프만 트리, 압축 해제된 데이터를 준비한다.<br>
![데이터압축해제 1](/assets/img/posts/2021-09-25-greedy-14.png){: width="700" height="150" }


압축 데이터에서 비트 하나를 읽는다. 0이므로 왼쪽 노드로 이동한다. 이동하니 잎 노드 a를 만난다. a를 압축 해제 버퍼에 추가하고 루트 노드로 돌아간다.<br>
![데이터압축해제 2](/assets/img/posts/2021-09-25-greedy-15.png){: width="700" height="150" }


세 번째 비트까지는 0이 읽혀 나오기 때문에 매번 a 노드를 만난다. 그러므로 그 때마다 a를 압축 해제 버퍼에 추가하고 루트 노드로 돌아간다.<br>
![데이터압축해제 3](/assets/img/posts/2021-09-25-greedy-16.png){: width="700" height="150" }


그 다음 비트를 읽으면 1이 나온다. 그럼 루트 노드에서 오른쪽으로 이동하는데, 잎 노드가 아니다. 이 경우에는 그 다음 비트를 읽는다. 0이 나오므로 현재 위치에서 왼쪽 자식 노드로 이동한다. 그러면 잎 노드가 아니므로 다시 비트 하나를 읽는다. 0이 나오므로 왼쪽 자식 노드로 이동하는데 잎 노드 b가 나온다. b를 압축 해제 버퍼에 추가하고 루트 노드로 돌아간다.<br>
![데이터압축해제 4](/assets/img/posts/2021-09-25-greedy-17.png){: width="700" height="150" }


그 이후로 압축 데이터에서 0만 두번 나오므로 두 개의 a가 압축 해제 버퍼에 추가된다.<br>
![데이터압축해제 5](/assets/img/posts/2021-09-25-greedy-18.png){: width="700" height="150" }


이번에 읽은 비트는 1이다. 루트 노드의 오른쪽 자식으로 이동하고 다시 비트를 읽는다. 0이므로 현재 노드의 왼쪽 자식 노드로 이동하고 또 비트를 읽는다. 이번엔 1이므로 오른쪽 자식 노드로 이동한다. 그러면 잎 노드 c에 도달한다. c를 압축 해제 버퍼에 추가하고 다시 루트 노드로 돌아간다.<br>
![데이터압축해제 6](/assets/img/posts/2021-09-25-greedy-19.png){: width="700" height="150" }


비트 하나를 읽으면 1이다. 루트 노드의 오른쪽 자식 노드로 이동하면 잎 노드가 아니므로 다시 비트 하나를 더 읽는다. 이번에도 1이므로 오른쪽 자식 노드로 이동한다. 그러면 잎 노드 d를 만난다. d를 압축 해제 버퍼에 추가하고 다시 루트 노드로 돌아간다.
![데이터압축해제 7](/assets/img/posts/2021-09-25-greedy-20.png){: width="700" height="150" }


압축 데이터에 남은 버퍼가 11 뿐이므로 위의 과정을 반복하여 또 하나의 d를 압축 해제 버퍼에 추가한다. 그러면 압축 해제가 종료된다. 압축 해제 버퍼의 내용을 읽으면 'aaabaacdd'를 얻으므로 원본과 동일함을 알 수 있다.<br>

<br>

### 허프만 코딩의 구현
다음 예제는 총 5개의 파일로 구성되어 있다.<br>
PriorityQueue.c, PriorityQueue.h, Huffman.c, Huffman.h, Test_Huffman.c<br>
PriorityQueue.h, PriorityQueue.c는 [우선순위 큐 예제 프로그램](/posts/priority-queue/#힙을-이용한-우선순위-큐의-구현){:target="_blank"}를 사용하면 된다.<br>
Huffman.h
```c
#ifndef HUFFMAN_H
#define HUFFMAN_H

#include <stdio.h>
#include <stdlib.h>
#include "PriorityQueue.h"

#define MAX_CHAR 256
#define MAX_BIT  8

typedef unsigned int  UINT;
typedef unsigned char UCHAR;

typedef struct TagSymbolInfo
{
    UCHAR Symbol;
    int   Frequency;
} SymbolInfo;

typedef struct TagHuffmanNode
{
    SymbolInfo             Data;
    struct TagHuffmanNode* Left;
    struct TagHuffmanNode* Right;
} HuffmanNode;

typedef struct TagBitBuffer
{
    UCHAR* Buffer;
    UINT   Size;
} BitBuffer;

typedef struct TagHuffmanCode
{
    UCHAR Code[MAX_BIT];
    int   Size;
} HuffmanCode;

HuffmanNode* Huffman_CreateNode( SymbolInfo NewData );
void Huffman_DestroyNode( HuffmanNode* Node );
void Huffman_DestroyTree( HuffmanNode* Node );
void Huffman_AddBit( BitBuffer* Buffer, char value );

void Huffman_Encode( HuffmanNode** Tree, UCHAR* Source, BitBuffer* Encoded, 
                     HuffmanCode CodeTable[MAX_CHAR] );
void Huffman_Decode( HuffmanNode* Tree, BitBuffer* Encoded, UCHAR* Decoded );
void Huffman_BuildPrefixTree( HuffmanNode** Tree, 
                              SymbolInfo SymbolInfoTable[MAX_CHAR] );
void Huffman_BuildCodeTable( HuffmanNode* Tree, HuffmanCode CodeTable[MAX_CHAR], 
                             UCHAR Code[MAX_BIT], int Size );
void Huffman_PrintBinary( BitBuffer* Buffer );

#endif
```
Huffman.c
```c
#include "Huffman.h"

HuffmanNode* Huffman_CreateNode( SymbolInfo NewData )
{
    HuffmanNode* NewNode = (HuffmanNode*)malloc( sizeof(HuffmanNode) );
    NewNode->Left    = NULL;
    NewNode->Right   = NULL;
    NewNode->Data    = NewData;

    return NewNode;
}

void Huffman_DestroyNode( HuffmanNode* Node )
{
    free(Node);
}

void Huffman_DestroyTree( HuffmanNode* Node )
{
    if ( Node == NULL )
        return;

    Huffman_DestroyTree( Node->Left );
    Huffman_DestroyTree( Node->Right );
    Huffman_DestroyNode( Node );
}

void Huffman_Huffman_AddBit( BitBuffer* Buffer, char Bit )
{
    UCHAR Mask = 0x80;
    
    if ( Buffer->Size % 8  == 0 ) 
    {
        Buffer->Buffer = 
            realloc(Buffer->Buffer, sizeof(UCHAR) * ((Buffer->Size / 8) + 1) );
        Buffer->Buffer[Buffer->Size / 8 ] = 0x00;
    }

    Mask >>= Buffer->Size % 8;

    if ( Bit == 1 )
       Buffer->Buffer[Buffer->Size / 8] |= Mask;
    else
      Buffer->Buffer[Buffer->Size / 8] &= ~Mask;

    Buffer->Size++;
}

void Huffman_BuildCodeTable( HuffmanNode* Tree, HuffmanCode CodeTable[MAX_CHAR], 
                            UCHAR Code[MAX_BIT], int Size )
{
    if ( Tree == NULL )
        return;
     
    if ( Tree->Left != NULL )
    {
        Code[Size] = 0;
        Huffman_BuildCodeTable( Tree->Left, CodeTable, Code, Size + 1 );
    }

    if ( Tree->Right != NULL )
    {
        Code[Size] = 1;
        Huffman_BuildCodeTable( Tree->Right, CodeTable, Code, Size + 1 );
    }

    if ( Tree->Left == NULL && Tree->Right == NULL )
    {
        int i;

        for ( i=0; i<Size; i++ ) 
            CodeTable[Tree->Data.Symbol].Code[i] = Code[i];

        CodeTable[Tree->Data.Symbol].Size = Size;
    }
}


void Huffman_BuildPrefixTree( HuffmanNode** Tree, 
                              SymbolInfo SymbolInfoTable[MAX_CHAR])
{
    int       i = 0;
    PQNode    Result;
    PriorityQueue* PQ = PQ_Create(0);
    

    for ( i=0; i<MAX_CHAR; i++ )
    {   
        if ( SymbolInfoTable[i].Frequency > 0 )
        {
            HuffmanNode* BitNode = Huffman_CreateNode( SymbolInfoTable[i] );
            PQNode NewNode;
			NewNode.Priority = SymbolInfoTable[i].Frequency;
			NewNode.Data     = BitNode;
            PQ_Enqueue( PQ, NewNode );
        }
    }

    while ( PQ->UsedSize > 1 )
    {
        SymbolInfo     NewData = { 0, 0 };
        HuffmanNode* BitNode = Huffman_CreateNode( NewData );
        HuffmanNode* Left;
        HuffmanNode* Right;

        PQNode QLeft;    
        PQNode QRight;
        PQNode NewNode;

        PQ_Dequeue( PQ, &QLeft );
        PQ_Dequeue( PQ, &QRight );

        Left  = (HuffmanNode*)QLeft.Data;
        Right = (HuffmanNode*)QRight.Data;

        BitNode->Data.Symbol = 0;
        BitNode->Data.Frequency =             
            Left->Data.Frequency + Right->Data.Frequency;

        BitNode->Left  = Left;
        BitNode->Right = Right;

        NewNode.Priority = BitNode->Data.Frequency;
        NewNode.Data     = BitNode;

        PQ_Enqueue( PQ, NewNode );
    }

    PQ_Dequeue( PQ, &Result );
    *Tree = (HuffmanNode*)Result.Data;    
}

void Huffman_Encode( HuffmanNode** Tree, UCHAR* Source, BitBuffer* Encoded, 
                    HuffmanCode CodeTable[MAX_CHAR] )
{
    int          i = 0,
                 j = 0;
    SymbolInfo     SymbolInfoTable[MAX_CHAR];
    UCHAR        Temporary[MAX_BIT];

    for ( i=0; i<MAX_CHAR; i++ ) 
    {
        SymbolInfoTable[i].Symbol    = i;
        SymbolInfoTable[i].Frequency = 0;
    }

    i=0;
    while ( Source[i] != '\0' )
    {
        SymbolInfoTable[Source[i++]].Frequency++;
    }

    Huffman_BuildPrefixTree( Tree, SymbolInfoTable );

    Huffman_BuildCodeTable( *Tree, CodeTable, Temporary, 0 );

    i=0;
    while ( Source[i] != '\0' )
    {
        int   BitCount = CodeTable[Source[i]].Size;

        for ( j=0; j<BitCount; j++ )
            Huffman_Huffman_AddBit( Encoded, CodeTable[Source[i]].Code[j] );
        
        i++;
    }
}

void Huffman_Decode( HuffmanNode* Tree, BitBuffer* Encoded, UCHAR* Decoded )
{
    int i;
    int Index = 0;
    HuffmanNode* Current = Tree;

    for ( i=0; i<=Encoded->Size; i++ )
    {
        UCHAR Mask = 0x80; /*  1000 0000 */
        
        if ( Current->Left == NULL && Current->Right == NULL )
        {
            Decoded[Index++] = Current->Data.Symbol;
            Current = Tree;
        }

        Mask >>= i % 8;

        if (  (Encoded->Buffer[i/8] & Mask) != Mask )
            Current = Current->Left;
        else
            Current = Current->Right;
    }

    Decoded[Index] = '\0';
}

void Huffman_PrintBinary( BitBuffer* Buffer )
{
    int i;

    for ( i=0; i<Buffer->Size; i++ )
    {
        UCHAR Mask = 0x80; /*  1000 0000 */
        Mask >>= i % 8;

        printf("%d", (Buffer->Buffer[i/8] & Mask) == Mask );
    }
}
```
Test_Huffman.c
```c
#include "Huffman.h"
#include <string.h>

int main( void )
{
    char* Source  = "http://www.seanlab.net";
    char* Decoded = "";

    HuffmanNode* Tree = NULL;
    BitBuffer    Encoded = {NULL, 0};
    HuffmanCode  CodeTable[MAX_CHAR];
    
    memset ( &CodeTable, 0, sizeof(HuffmanCode) * MAX_CHAR );
    
    Huffman_Encode( &Tree, Source, &Encoded, CodeTable );
    
    printf("Original Size:%d Encoded Size:%d\n", 
        (strlen(Source) + 1) * sizeof(char) * 8, Encoded.Size);

    Decoded = (char*)malloc(sizeof(char) * (strlen(Source) + 1));
    Huffman_Decode( Tree, &Encoded, Decoded );

    printf("Original : %s\n", Source );
    printf("Encoded  : ");
    
    Huffman_PrintBinary( &Encoded );

    printf("\n");

    printf("Decoded  : %s\n", Decoded );

    Huffman_DestroyTree( Tree );
    free( Decoded );

    return 0;
}
```

<br>

\# 참고<br>
[박상현 / 뇌를 자극하는 알고리즘](https://www.hanbit.co.kr/media/books/book_view.html?p_code=B3450156021){:target="_blank"}<br>